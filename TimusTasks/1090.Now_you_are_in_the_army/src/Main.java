import java.io.*;
import java.util.*;

//1097. Квадратная страна 2
//Ограничение времени: 1.0 секунды
//Ограничение памяти: 64 МБ
//Квадратная Дума Квадратной страны постановила создать Национальный квадратный парк. Конечно же, парк должен занимать большой квадрат. К сожалению, на данный момент многие квадратные граждане инвестировали (не без помощи участников последнего чемпионата) свои квадрики в землю так, что часть страны уже занята. Возможно, не получится найти землю для парка, не затрагивая интересы частных владельцев. Если это действительно так, некоторые участки земли придется экспроприировать.
//Во избежание социальных волнений Дума должна разместить парк так, чтобы были затронуты интересы как можно менее влиятельных граждан. Лучше экспроприировать землю у тысячи простых граждан, чем у одного депутата или одного владельца банка.
//        Все земли, принадлежащие жителям Квадратной страны, отмечены целыми числами от 2 до 100 в зависимости от влиятельности владельца: земли Квадратного президента отмечены числом 100, земли олигархов – числом 99, земли депутатов – числом 98 и т.д.
//        Кроме того, некоторые земельные участки принадлежат членам (не квадратного) жюри, которые придумали эту задачу. Эта земля отмечена числом 255 и не может быть экспроприирована вообще.
//Исходные данные
//В первой строке указаны целые числа L и A – длина стороны Квадратной страны и длина стороны парка соответственно (1 ≤ A ≤ L ≤ 10000). Следующая строка содержит целое число M – количество занятых участков земли (1 ≤ M ≤ 100). Согласно квадратным законам, участок земли – это квадрат с целыми координатами вершин, стороны которого параллельны осям координат. Координаты левого нижнего угла Квадратной страны – (1, 1).
//Следующие M строк содержат информацию о занятых участках земли: влиятельность владельца, длину стороны квадрата и координаты левого нижнего угла. Влиятельность – целое число от 2 до 100 или число 255. Длина и координаты – целые числа от 1 до L. Каждый участок земли целиком находится в пределах страны и может пересекаться с другими участками земли только по своей границе. Вся земля, не принадлежащая ни одному занятому участку, является свободной.
//Результат
//Если можно построить парк на свободных землях, выведите число 1. Иначе выведите минимально возможную влиятельность владельцев земли, которую нужно экспроприировать (целое число от 2 до 100). Количество и площадь экспроприированных земельных участков не имеют значения. Следует учитывать влиятельность только самых влиятельных землевладельцев среди тех, которые пострадают от создания парка.
//Если невозможно создать парк, не включающий в себя земли членов жюри, выведите слово «IMPOSSIBLE».

public class Main {
    // Дерево Фенвика для подсчета количества встреченных чисел
    static class Fenwick {
        int[] tree;
        int size;

        Fenwick(int n) {
            size = n;
            tree = new int[n + 1];
        }

        // Добавление 1 в позицию idx
        void add(int idx, int delta) {
            while (idx <= size) {
                tree[idx] += delta;
                idx += idx & -idx;
            }
        }

        // Сумма на префиксе [1..idx]
        int sum(int idx) {
            int s = 0;
            while (idx > 0) {
                s += tree[idx];
                idx -= idx & -idx;
            }
            return s;
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());

        int maxInv = -1;
        int bestRow = 0;

        for (int row = 1; row <= K; row++) {
            st = new StringTokenizer(br.readLine());
            Fenwick ft = new Fenwick(N);
            long total = 0; // Общее количество прыжков в текущей шеренге

            for (int i = 0; i < N; i++) {
                int x = Integer.parseInt(st.nextToken());
                // Количество уже встреченных чисел, меньших x
                int less = ft.sum(x - 1);
                // Количество больших чисел перед текущим
                int greater = i - less;
                total += greater;
                // Добавляем текущее число в дерево
                ft.add(x, 1);
            }

            // Сравниваем с текущим максимумом
            if (total > maxInv) {
                maxInv = (int) total;
                bestRow = row;
            }
        }

        pw.println(bestRow);
        pw.flush();
    }
}