import java.util.Scanner;

//1709. Пингвин-Авиа
//Ограничение времени: 1.0 секунды
//Ограничение памяти: 64 МБ
//Авиакомпания Пингвин-Авиа, как и многие другие антарктические авиакомпании, испытывает финансовые трудности в период мирового экономического кризиса. Жители Антарктиды теперь экономят на полётах и чаще пользуются поездами или вообще предпочитают сидеть дома. Руководство авиакомпании надеется, что летом поток клиентов возрастёт за счёт желающих отдохнуть на приморских курортах Антарктиды. Чтобы дотянуть до лета, было решено оптимизировать схему авиарейсов, временно сократив часть рейсов и, возможно, введя несколько новых.
//Директор Пингвин-Авиа считает, что после оптимизации схема полётов должна обладать следующими свойствами:
//Рейсами Пингвин-Авиа можно добраться из любого аэропорта Антарктиды до любого другого. Возможно, для этого придётся сделать несколько пересадок.
//Схема должна содержать минимальное число рейсов среди всех схем, отвечающих первому свойству.
//Но в Антарктиде не всё так просто. За отмену существующего рейса с авиакомпании взимается разовая неустойка в размере d антарктических долларов. Кроме того, чтобы получить слоты под новый рейс, надо дать взятку крёстному отцу антарктической мафии по прозвищу Белый медведь в размере a антарктических долларов.
//Помогите директору Пингвин-Авиа трансформировать существующее расписание полётов, потратив при этом наименьшую сумму денег, и вы получите за это проездной билет на все рейсы авиакомпании.
//Исходные данные
//В первой строке записано целое число n — количество аэропортов в Антарктиде, 2 ≤ n ≤ 100. Во второй строке через пробел записаны целые числа d и a, 1 ≤ d, a ≤ 106. В следующих n строках записана существующая схема полётов Пингвин-Авиа в виде матрицы размером n × n. В ячейке (i, j) матрицы стоит единица, если авиакомпания совершает рейс между аэропортами i и j. В противном случае в ячейке стоит нуль. Гарантируется, что матрица симметрична и на её диагонали стоят нули.
//        Результат
//В первой строке выведите наименьшую сумму денег, которую придётся потратить для оптимизации существующей схемы полётов. В следующих n строках выведите план изменения схемы в виде матрицы размера n × n. Ячейка (i, j) матрицы содержит символ «d», если нужно отменить существующий рейс между аэропортами i и j. Если нужно ввести новый рейс между этими аэропортами, ячейка содержит символ «a». Все остальные ячейки матрицы содержат символ «0». Матрица должна быть симметричной. Если существует несколько оптимальных схем, выведите любую из них.

public class Main {
    static class DSU {
        int[] parent;
        int[] rank;

        public DSU(int n) {
            parent = new int[n];
            rank = new int[n];
            for (int i = 0; i < n; i++) {
                parent[i] = i;
            }
        }

        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]);
            }
            return parent[x];
        }

        public boolean union(int x, int y) {
            int rootX = find(x);
            int rootY = find(y);
            if (rootX == rootY) {
                return false;
            }
            if (rank[rootX] < rank[rootY]) {
                parent[rootX] = rootY;
            } else if (rank[rootX] > rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
            return true;
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = Integer.parseInt(scanner.nextLine());
        String[] da = scanner.nextLine().split(" ");
        int d = Integer.parseInt(da[0]);
        int a = Integer.parseInt(da[1]);

        char[][] graph = new char[n][n];
        for (int i = 0; i < n; i++) {
            String line = scanner.nextLine();
            graph[i] = line.toCharArray();
        }

        int m = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == '1') {
                    m++;
                }
            }
        }

        DSU dsu = new DSU(n);
        char[][] result = new char[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                result[i][j] = '0';
            }
        }

        int x = 0;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == '1') {
                    if (dsu.union(i, j)) {
                        x++;
                    } else {
                        result[i][j] = 'd';
                        result[j][i] = 'd';
                    }
                }
            }
        }

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == '0') {
                    if (dsu.find(i) != dsu.find(j)) {
                        dsu.union(i, j);
                        result[i][j] = 'a';
                        result[j][i] = 'a';
                    }
                }
            }
        }

        long cost = (long) d * (m - x) + (long) a * (n - 1 - x);
        System.out.println(cost);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(result[i][j]);
            }
            System.out.println();
        }
    }
}