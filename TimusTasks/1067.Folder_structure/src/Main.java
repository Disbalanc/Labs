import java.io.*;
import java.util.*;

//1067. Структура папок
//Ограничение времени: 2.0 секунды
//Ограничение памяти: 64 МБ
//Хакер Билл случайно потерял всю информацию с жесткого диска своего компьютера, и у него нет резервных копий его содержимого. Но он сожалеет не о потере самих файлов, а о потере очень понятной и удобной структуры папок, которую он создавал и сохранял в течение многих лет работы.
//        К счастью, у Билла есть несколько копий списков папок с его жесткого диска. С помощью этих списков он смог восстановить полные пути к некоторым папкам (например, «WINNT\SYSTEM32\CERTSRV\CERTCO~1\X86»). Он поместил их все в файл, записав каждый найденный путь в отдельную строку.
//        Напишите программу, которая восстановит структуру папок Билла и выведет ее в виде отформатированного дерева.
//        Исходные данные
//Первая строка содержит целое число N – количество различных путей к папкам (1 ≤ N ≤ 500). Далее следуют N строк с путями к папкам. Каждый путь занимает одну строку и не содержит пробелов, в том числе, начальных и конечных. Длина каждого пути не превышает 80 символов. Каждый путь встречается в списке один раз и состоит из нескольких имен папок, разделенных обратной косой чертой («\»).
//Имя каждой папки состоит из 1-8 заглавных букв, цифр или специальных символов из следующего списка: восклицательный знак, решетка, знак доллара, знак процента, амперсанд, апостроф, открывающаяся и закрывающаяся скобки, знак дефиса, собаки, циркумфлекс, подчеркивание, гравис, открывающаяся и закрывающаяся фигурная скобка и тильда («!#$%&'()-@^_`{}~»).
//        Результат
//        Выведите отформатированное дерево папок. Каждое имя папки должно быть выведено в отдельной строке, перед ним должно стоять несколько пробелов, указывающих на глубину этой папки в иерархии. Подпапки должны быть перечислены в лексикографическом порядке непосредственно после их родительской папки; перед их именем должно стоять на один пробел больше, чем перед именем их родительской папки. Папки верхнего уровня выводятся без пробелов и также должны быть перечислены в лексикографическом порядке.

public class Main {
    // Класс для узла дерева папок
    static class FolderNode {
        String name;
        TreeMap<String, FolderNode> children; // Дети в лексикографическом порядке

        FolderNode(String name) {
            this.name = name;
            this.children = new TreeMap<>();
        }

        // Добавление пути в дерево
        void addPath(String[] path, int index) {
            if (index >= path.length) return;

            String currentName = path[index];
            FolderNode child = children.get(currentName);

            if (child == null) {
                child = new FolderNode(currentName);
                children.put(currentName, child);
            }

            child.addPath(path, index + 1);
        }

        // Вывод дерева с отступами
        void printTree(int level, PrintWriter out) {
            if (!name.isEmpty()) {
                // Отступ = (level-1) пробелов
                for (int i = 1; i < level; i++) {
                    out.print(" ");
                }
                out.println(name);
            }

            // Рекурсивно выводим детей
            for (FolderNode child : children.values()) {
                child.printTree(level + 1, out);
            }
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(System.out);

        int N = Integer.parseInt(br.readLine().trim());
        FolderNode root = new FolderNode(""); // Корневой узел

        // Чтение и обработка всех путей
        for (int i = 0; i < N; i++) {
            String path = br.readLine().trim();
            String[] folders = path.split("\\\\"); // Разделение по обратному слешу
            root.addPath(folders, 0);
        }

        // Вывод дерева
        root.printTree(0, out);

        out.flush();
    }
}