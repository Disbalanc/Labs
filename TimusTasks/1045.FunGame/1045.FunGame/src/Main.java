import java.util.*;

//1045. Забавная игра
//Ограничение времени: 1.0 секунды
//Ограничение памяти: 64 МБ
//В одной стране есть несколько аэропортов, между некоторыми аэропортами есть рейсы. Можно перелететь из любого аэропорта в любой другой, возможно, с несколькими пересадками. Для каждой пары аэропортов существует только одна последовательность рейсов, соединяющая эти аэропорты.
//Два террориста играют в игру. Они делают ходы по очереди. Каждый ход заключается в следующих действиях. Игрок минирует аэропорт, выбирает рейс и улетает вместе со своим коллегой. После взлёта он активирует радиоуправляемый взрыватель. В результате аэропорт, который только что покинули террористы, разрушен, и рейсы в этот аэропорт и из него больше невозможны. После того, как самолёт приземляется, другой игрок делает ход — и дальше по очереди. Проигрывает тот, кто не может сделать ход.
//        Напишите программу, которая по начальному списку полётов и номеру аэропорта, в котором террористы начинают игру, определяет, кто выигрывает, если террористы играют идеально (каждый выбирает лучший ход).
//Исходные данные
//Первая строка содержит два целых числа: n и k, разделённые пробелом. Здесь n — количество аэропортов (n ≤ 1000), а k — номер аэропорта, являющегося начальной точкой игры (1 ≤ k ≤ n). Следующая n − 1 строка содержит пары целых чисел, разделённых пробелами. Это номера аэропортов, соединённых рейсом. Все рейсы двусторонние и упомянуты только один раз. Каждый аэропорт соединён рейсами не более, чем с 20 другими.
//        Результат
//        Если игрок, начинающий игру, выигрывает, программа должна написать «First player wins flying to airport L», где L — номер аэропорта, в который игрок должен вылететь из текущего. Если таких аэропортов несколько, программа должна выбрать вариант с меньшим номером аэропорта. Если начинающий игрок проигрывает, программа должна написать «First player loses».

public class Main {
    static List<Integer>[] graph;
    static List<Integer>[] children;
    static boolean[] win;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();

        // Инициализация графа
        graph = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            graph[i] = new ArrayList<>();
        }

        // Чтение рёбер
        for (int i = 0; i < n - 1; i++) {
            int a = sc.nextInt();
            int b = sc.nextInt();
            graph[a].add(b);
            graph[b].add(a);
        }

        // Построение дерева с корнем в k
        children = new ArrayList[n + 1];
        for (int i = 1; i <= n; i++) {
            children[i] = new ArrayList<>();
        }
        buildTree(k, -1);

        // Вычисление выигрышных позиций
        win = new boolean[n + 1];
        computeWin(k);

        // Определение результата
        if (win[k]) {
            int minAirport = Integer.MAX_VALUE;
            for (int child : children[k]) {
                if (!win[child]) {
                    if (child < minAirport) {
                        minAirport = child;
                    }
                }
            }
            System.out.println("First player wins flying to airport " + minAirport);
        } else {
            System.out.println("First player loses");
        }

        sc.close();
    }

    // Построение дерева с корнем в v
    static void buildTree(int v, int parent) {
        for (int u : graph[v]) {
            if (u != parent) {
                children[v].add(u);
                buildTree(u, v);
            }
        }
    }

    // Рекурсивное вычисление выигрышных позиций
    static boolean computeWin(int v) {
        // Если нет детей - проигрышная позиция
        if (children[v].isEmpty()) {
            win[v] = false;
            return false;
        }

        // Проверяем всех детей
        for (int child : children[v]) {
            // Если найдётся ребёнок с проигрышной позицией - текущая позиция выигрышная
            if (!computeWin(child)) {
                win[v] = true;
                return true;
            }
        }

        // Если все дети ведут к выигрышным позициям - текущая позиция проигрышная
        win[v] = false;
        return false;
    }
}